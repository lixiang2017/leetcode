'''
DP (like BFS)
T: O(NK)
S: O(2N)

执行用时：184 ms, 在所有 Python3 提交中击败了59.08% 的用户
内存消耗：15.5 MB, 在所有 Python3 提交中击败了62.35% 的用户
'''
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        dp = [float(inf)] * n
        dp[src] = 0
        for _ in range(k + 1):
            level = dp[:]
            for u, v, w in flights:
                dp[v] = min(dp[v], level[u] + w)

        return dp[dst] if dp[dst] != float('inf') else -1

'''
17
[[0,12,28],[5,6,39],[8,6,59],[13,15,7],[13,12,38],[10,12,35],[15,3,23],[7,11,26],[9,4,65],[10,2,38],[4,7,7],[14,15,31],[2,12,44],[8,10,34],[13,6,29],[5,14,89],[11,16,13],[7,3,46],[10,15,19],[12,4,58],[13,16,11],[16,4,76],[2,0,12],[15,0,22],[16,12,13],[7,1,29],[7,14,100],[16,1,14],[9,6,74],[11,1,73],[2,11,60],[10,11,85],[2,5,49],[3,4,17],[4,9,77],[16,3,47],[15,6,78],[14,1,90],[10,5,95],[1,11,30],[11,0,37],[10,4,86],[0,8,57],[6,14,68],[16,8,3],[13,0,65],[2,13,6],[5,13,5],[8,11,31],[6,10,20],[6,2,33],[9,1,3],[14,9,58],[12,3,19],[11,2,74],[12,14,48],[16,11,100],[3,12,38],[12,13,77],[10,9,99],[15,13,98],[15,12,71],[1,4,28],[7,0,83],[3,5,100],[8,9,14],[15,11,57],[3,6,65],[1,3,45],[14,7,74],[2,10,39],[4,8,73],[13,5,77],[10,0,43],[12,9,92],[8,2,26],[1,7,7],[9,12,10],[13,11,64],[8,13,80],[6,12,74],[9,7,35],[0,15,48],[3,7,87],[16,9,42],[5,16,64],[4,5,65],[15,14,70],[12,0,13],[16,14,52],[3,10,80],[14,11,85],[15,2,77],[4,11,19],[2,7,49],[10,7,78],[14,6,84],[13,7,50],[11,6,75],[5,10,46],[13,8,43],[9,10,49],[7,12,64],[0,10,76],[5,9,77],[8,3,28],[11,9,28],[12,16,87],[12,6,24],[9,15,94],[5,7,77],[4,10,18],[7,2,11],[9,5,41]]
13
4
13
'''

'''
15
[[10,14,43],[1,12,62],[4,2,62],[14,10,49],[9,5,29],[13,7,53],[4,12,90],[14,9,38],[11,2,64],[2,13,92],[11,5,42],[10,1,89],[14,0,32],[9,4,81],[3,6,97],[7,13,35],[11,9,63],[5,7,82],[13,6,57],[4,5,100],[2,9,34],[11,13,1],[14,8,1],[12,10,42],[2,4,41],[0,6,55],[5,12,1],[13,3,67],[3,13,36],[3,12,73],[7,5,72],[5,6,100],[7,6,52],[4,7,43],[6,3,67],[3,1,66],[8,12,30],[8,3,42],[9,3,57],[12,6,31],[2,7,10],[14,4,91],[2,3,29],[8,9,29],[2,11,65],[3,8,49],[6,14,22],[4,6,38],[13,0,78],[1,10,97],[8,14,40],[7,9,3],[14,6,4],[4,8,75],[1,6,56]]
1
4
10
'''

'''
这个算法应该是正确的，只是太慢了。

46 / 49 个通过测试用例
状态：超出时间限制
提交时间：几秒前
最后执行的输入：
13
[[11,12,74],[1,8,91],[4,6,13],[7,6,39],[5,12,8],[0,12,54],[8,4,32],[0,11,4],[4,0,91],[11,7,64],[6,3,88],[8,5,80],[11,10,91],[10,0,60],[8,7,92],[12,6,78],[6,2,8],[4,3,54],[3,11,76],[3,12,23],[11,6,79],[6,12,36],[2,11,100],[2,5,49],[7,0,17],[5,8,95],[3,9,98],[8,10,61],[2,12,38],[5,7,58],[9,4,37],[8,6,79],[9,0,1],[2,3,12],[7,10,7],[12,10,52],[7,2,68],[12,2,100],[6,9,53],[7,4,90],[0,5,43],[11,2,52],[11,8,50],[12,4,38],[7,9,94],[2,7,38],[3,7,88],[9,12,20],[12,0,26],[10,5,38],[12,8,50],[0,2,77],[11,0,13],[9,10,76],[2,6,67],[5,6,34],[9,7,62],[5,3,67]]
10
1
10
'''
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        # graph
        g = defaultdict(dict)
        for a, b, p in flights:
            g[a][b] = p
        h = [(0, src, k + 1)]
        while h:
            p, i, k = heapq.heappop(h)
            if i == dst:
                return p
            if k > 0:
                for j in g[i]:
                    heapq.heappush(h, (p + g[i][j], j, k - 1))
        return -1


'''
这个算法是错误的！不能使用seen_path!!!
This algorithm is wrong, we cannot use seen_path!

e.g.  s----->[A]----------------600------------------------->[B]-------300-------->[C]----->t
              \ ---2-->[D]---3-->[E]---4--->[F]------5------/
A-->B-->C 中 B-->C 这一段先加入seen_path了。之后的A-->F-->D--->E-->F-->B-->C不会再访问了。因而错失了更低的价格（更短的路径）。
这个例子并不合适。因为在堆中，下面这条路线更短，肯定更先访问。


https://leetcode.com/problems/cheapest-flights-within-k-stops/discuss/115541/JavaPython-Priority-Queue-Solution


45 / 49 个通过测试用例
状态：解答错误
提交时间：几秒前
最后执行的输入：
5
[[0,1,5],[1,2,5],[0,3,2],[3,1,2],[1,4,1],[4,2,1]]
0
2
2
'''
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        # graph
        g = defaultdict(dict)
        for a, b, p in flights:
            g[a][b] = p
        h = [(0, src, k + 1)]
        seen_path = set()
        while h:
            p, i, k = heapq.heappop(h)
            if i == dst:
                return p
            if k > 0:
                for j in g[i]:
                    if (i, j) not in seen_path:
                        seen_path.add((i, j))
                        heapq.heappush(h, (p + g[i][j], j, k - 1))
        return -1








