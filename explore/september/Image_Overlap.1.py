# coding=utf8

'''
由于只有值为1的地方才有可能重叠，所以我们只关心A和B中值为1的地方。
由于对于A和B中的任意两个1的位置，肯定有一种方法能将A平移到B，平移的方法就是横向平移其横坐标之差，竖向平移其纵坐标之差。
由于其是一一对应关系，所以只要是横纵坐标差相同的两对儿位置，一定是在同一次平移上。
那么我们就需要一个 HashMap 来建立坐标差值和其出现次数之间的映射。
最后在 HashMap 中找到最大的值即可。

49 / 49 test cases passed.
    Status: Accepted
Runtime: 680 ms
Memory Usage: 13.2 MB
'''

import collections

class Solution(object):
    def largestOverlap(self, A, B):
        """
        :type A: List[List[int]]
        :type B: List[List[int]]
        :rtype: int
        """
        count = collections.Counter()
        for i, row in enumerate(A):
            for j, v in enumerate(row):
                if v:
                    for i2, row2 in enumerate(B):
                        for j2, v2 in enumerate(row2):
                            if v2:
                                count[i - i2, j - j2] += 1


        return max(count.values() or [0])

        
if __name__ == '__main__':
    A = [[1,1,0],
        [0,1,0],
        [0,1,0]]
    B = [[0,0,0],
        [0,1,1],
        [0,0,1]]
    assert Solution().largestOverlap(A, B) == 3

    A = [[1,1,1,0,1,0,1,1,1,1,1,1,1,0,1],[1,1,1,1,0,0,1,1,1,1,1,0,1,0,0],[0,1,1,0,1,1,1,0,1,1,1,0,1,1,1],[0,1,0,1,0,1,0,1,1,1,1,1,1,1,0],[1,1,1,1,1,0,0,0,1,1,1,0,1,1,0],[0,1,0,0,1,0,0,1,1,1,1,1,1,1,0],[1,1,1,0,1,1,1,1,1,0,1,0,1,0,0],[0,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0,0,1,1,1,0,1,1,0,1,1,1,1,1],[1,0,1,0,0,1,1,1,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,1,0,0,1,1,1,1],[0,1,1,1,0,1,1,1,0,1,1,0,1,0,1],[1,1,0,1,1,0,1,0,1,1,1,1,1,0,1],[0,1,1,1,1,1,0,1,1,1,0,1,1,0,1],[0,1,0,1,1,0,1,1,1,0,1,1,1,0,1]]
    B = [[1,0,0,1,1,1,1,1,1,1,1,0,1,0,0],[1,0,0,1,0,1,1,1,1,0,1,1,0,1,1],[1,1,1,1,1,1,1,1,0,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,0,0,1,0,0,0],[0,1,1,1,0,1,0,0,1,1,0,1,0,1,0],[1,1,1,1,1,1,1,1,0,1,1,1,0,1,1],[1,1,0,1,1,1,1,0,0,1,0,0,1,0,0],[1,1,1,0,0,1,1,1,1,1,1,1,1,1,0],[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,0,1,1,1,1,1,1,1,1,1,1,0],[1,1,1,0,1,0,0,1,1,1,1,0,0,1,0],[1,1,1,0,0,1,1,0,1,1,1,1,1,0,1],[1,1,1,1,1,1,1,1,1,0,1,0,1,1,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,0]]
    print Solution().largestOverlap(A, B)   # 122
