'''
Time Limit Exceeded
T: O((MN)^2)

Python3语言环境
3301ms时间消耗
6.54MB空间消耗
0.00%击败提交
'''
from collections import deque

class Solution:
    """
    @param grid: a 2D grid
    @return: An integer
    """
    def shortestDistance(self, grid):
        # write your code here
        M, N = len(grid), len(grid[0])
        house, wall, empty = set(), set(), set()
        for i in range(M):
            for j in range(N):
                if grid[i][j] == 0:
                    empty.add((i, j))
                elif grid[i][j] == 1:
                    house.add((i, j))
                else: # 2
                    wall.add((i, j))
        h_cnt = len(house)

        ans = float('inf')
        # for every empty
        for ei, ej in empty:
            dist = 0
            seen = set((ei, ej))
            seen_house_cnt = 0
            q = deque([(ei, ej, 0)])
            while q:
                x, y, step = q.popleft()
                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] != 2 and (nx, ny) not in seen:
                        if grid[nx][ny] == 1:
                            dist += step + 1
                            seen_house_cnt += 1
                        elif grid[nx][ny] == 0:
                            q.append((nx, ny, step + 1))
                        seen.add((nx, ny))

            if seen_house_cnt == h_cnt:
                ans = min(ans, dist)

        return [ans, -1][ans == float('inf')]


'''
[[0,1,0],[1,1,1],[0,1,0]]
输出数据
10
期望答案
-1

[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,1,0,0]]
'''

'''
[[2,0,2,0,0,0,0,0,2,2,1,0,1,1,2,0,1,0,0,0,1,1,1,1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,2,2,0,0,1,1,0,0,1,0,0,2,0,2,1,0,0],[0,1,0,0,0,0,0,2,1,0,1,0,0,2,1,0,1,2,0,1,0,0,2,0,0,0,0,0,1,0,0,2,0,2,2,2,0,0,2,1,0,0,0,0,0,1,2,1,0,1,0,1,0,0,0],[1,0,0,0,0,0,0,1,1,0,1,0,0,1,0,2,1,2,2,0,1,0,0,1,2,1,0,1,0,0,0,0,1,0,0,0,2,2,2,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0],[2,2,1,2,2,0,0,2,1,2,1,2,1,0,0,0,0,0,0,1,0,0,2,0,1,1,0,2,0,1,0,0,2,0,0,0,0,2,0,0,0,0,0,0,1,2,0,0,0,0,0,2,1,2,2],[0,2,0,0,0,0,2,0,0,0,0,1,0,2,0,2,1,0,0,1,0,0,0,0,2,0,0,0,0,1,0,0,0,0,1,2,2,2,0,0,0,2,1,1,0,0,2,0,0,0,0,1,1,0,0],[1,0,0,0,0,0,1,1,2,0,0,0,1,0,1,0,2,2,0,0,1,0,0,0,2,0,2,0,0,0,1,0,1,0,0,0,2,0,0,1,2,0,2,0,0,0,0,2,0,0,1,0,0,0,0],[2,0,2,0,0,0,0,0,0,2,0,0,2,1,2,2,1,0,0,2,0,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,2,0,1,2,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0],[0,1,0,0,1,0,0,2,0,1,0,2,2,0,2,0,0,0,2,2,0,0,0,0,0,1,0,1,0,2,2,0,1,0,0,2,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,2,2],[0,0,0,0,1,0,0,0,0,2,0,0,0,1,2,2,2,0,0,0,0,1,1,2,0,1,0,2,0,0,0,0,0,2,1,2,2,1,0,0,1,1,2,0,0,1,0,0,0,0,0,0,0,1,0],[2,0,1,0,1,0,1,0,0,2,0,1,1,0,0,0,0,2,0,1,0,0,2,0,0,1,2,0,0,0,0,0,2,0,2,0,0,0,1,0,0,0,0,1,0,0,1,0,2,0,0,0,0,0,0],[2,0,2,0,2,2,1,0,0,0,1,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,1,2,0,0,0,1,0,0,0,1,0,1,1,0,1,0,0],[0,1,0,1,0,2,0,1,0,1,0,2,0,0,0,2,0,0,0,1,1,0,0,0,0,0,1,2,0,0,0,0,0,0,1,0,0,0,0,1,0,2,2,2,0,1,1,0,1,0,1,0,1,1,2],[0,2,0,2,0,0,0,1,0,0,2,1,0,1,0,0,0,1,2,2,0,1,1,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,1,0,2,0,0,1,1,1,1,0,0,2,1,1,0,0,0],[0,1,1,0,0,0,2,0,0,0,0,1,0,0,2,0,0,0,1,0,0,0,0,2,0,0,0,1,2,0,0,0,0,2,0,1,2,1,0,2,0,0,0,0,0,2,0,2,0,0,0,0,2,2,0],[0,1,0,0,2,0,1,0,2,0,0,0,0,1,0,2,0,0,0,0,1,1,2,2,0,1,2,0,0,0,0,2,1,0,2,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,2,0,0,0],[1,2,0,0,0,2,0,0,0,0,2,0,0,0,0,1,0,0,0,0,0,1,1,0,0,2,0,0,0,0,2,0,0,0,0,0,1,1,0,0,1,0,0,0,2,0,0,0,1,0,0,0,0,0,0],[2,0,0,2,0,2,1,2,2,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,0,2,0,2,0,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[0,0,1,0,1,1,0,2,0,2,0,1,0,0,0,1,0,0,2,0,0,2,0,0,2,0,0,0,0,1,0,0,0,0,2,0,0,2,0,1,0,0,0,2,0,0,1,0,0,1,0,1,0,0,0],[0,0,0,1,0,0,2,1,2,1,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,1,1,0,0,0,1,0,0,0,1,0,0,1,1,2,1,1,0,1,0,0,0,0,0,1,1,0,0,1,0],[0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,2,1,1,1,1,1,0,1,0,0,0,0,2,2,0,0,0,0,1,1,1,2,0,0,0,1,0,1,0,1,0,1,2,0,0,0,0,1,1],[0,0,2,1,0,0,2,2,0,0,0,2,0,2,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,2,1,0,0,0,2,0,0,0,1,2,0,0,1,0,1,1,0,1,0,0,1,0,1,0,0],[0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,2,0,2,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,2,0,0,1,2,0,0],[0,1,0,0,1,1,0,0,0,1,0,2,0,1,0,1,1,1,1,0,1,1,1,0,2,2,0,0,0,0,1,1,0,0,2,0,0,0,2,1,1,0,0,0,0,0,1,0,0,1,0,0,2,0,0],[0,0,1,0,2,0,2,1,0,0,0,0,0,0,0,1,0,1,2,0,0,2,2,0,1,2,0,0,0,0,0,1,0,2,1,0,0,1,0,0,0,0,2,0,0,1,0,0,0,0,1,1,0,1,1],[1,2,1,1,1,2,2,0,0,2,0,0,2,0,2,0,0,1,2,1,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,2,0,1,2,0,0,2,0,0,0,0,0,0,1,0,0,1],[1,0,0,1,0,2,0,2,1,0,0,0,0,0,2,1,2,0,0,0,1,0,1,0,0,0,2,0,1,0,2,0,0,0,1,0,2,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,0],[1,0,0,1,0,1,2,0,1,0,0,1,0,1,0,1,2,0,0,1,0,2,1,0,1,0,0,0,0,2,0,0,1,1,0,0,0,0,0,2,0,0,1,0,1,0,0,0,0,0,0,0,2,0,1],[0,0,0,2,0,0,1,2,1,0,0,2,0,0,0,0,2,1,2,0,2,2,0,0,2,0,0,0,2,0,2,0,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0],[0,0,1,1,0,0,0,2,1,0,2,2,2,0,0,1,0,0,0,2,1,0,2,0,0,0,2,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0],[2,0,2,1,0,0,1,0,0,0,0,1,2,0,1,0,0,0,0,2,0,1,0,0,0,0,0,0,0,2,0,0,0,0,1,1,1,0,1,1,0,2,1,0,0,1,2,0,2,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,2,1,0,2,0,0,0,1,0,0,1,0,2,1,0,0,0,0,0,0,0,0,0,0,0,2,0,1,0,1,0,0,0,1,0,0,0,0,1,0,1,0,0,0,0,0,2],[0,1,0,0,1,0,0,1,1,0,1,0,0,1,2,0,0,0,0,0,1,0,1,0,2,0,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,0,2,0,0,1,0,0,1,0,1,0,2],[0,0,0,0,1,0,0,0,0,2,1,0,2,2,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,2,2,1,0,0,2,0,2,1,2,0,1,0],[0,0,0,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,0,0,1,0,0,1,0,0,1,1,2,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,2,0],[0,0,1,0,0,0,0,2,0,0,0,2,1,0,0,0,0,0,2,0,0,2,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,2,0,0,0,1,2,0,0,0,1,0,0,1,1,0,2,0],[0,0,0,1,2,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,2,1,2,0,1,1,0,0,0,1,0,0,0,0,1,1,0,2,1,0,1,0,1,1,2,0,0,0,0,0,0,0],[2,0,2,2,0,1,0,0,0,2,0,0,0,0,1,1,0,0,0,0,2,0,0,0,0,0,2,2,0,0,2,2,0,0,0,1,1,2,0,1,0,0,2,1,0,2,0,0,1,0,2,1,2,1,2]]

期望答案
-1
'''


'''
TLE
add too_large flag, still TLE

'''
from collections import deque

class Solution:
    """
    @param grid: a 2D grid
    @return: An integer
    """
    def shortestDistance(self, grid):
        # write your code here
        M, N = len(grid), len(grid[0])
        house, wall, empty = set(), set(), set()
        for i in range(M):
            for j in range(N):
                if grid[i][j] == 0:
                    empty.add((i, j))
                elif grid[i][j] == 1:
                    house.add((i, j))
                else: # 2
                    wall.add((i, j))
        h_cnt = len(house)

        ans = float('inf')
        # for every empty
        for ei, ej in empty:
            dist = 0
            seen = set((ei, ej))
            seen_house_cnt = 0
            q = deque([(ei, ej, 0)])
            too_large = False
            while q:
                x, y, step = q.popleft()
                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < M and 0 <= ny < N and grid[nx][ny] != 2 and (nx, ny) not in seen:
                        if grid[nx][ny] == 1:
                            dist += step + 1
                            seen_house_cnt += 1
                            if dist >= ans:
                                too_large = True
                                break
                        elif grid[nx][ny] == 0:
                            q.append((nx, ny, step + 1))
                        seen.add((nx, ny))
                if too_large:
                    break

            if seen_house_cnt == h_cnt:
                ans = min(ans, dist)

        return [ans, -1][ans == float('inf')]


'''
BFS

845 ms时间消耗·
6.27 MB空间消耗·
您的提交打败了80.00 %的提交
'''

from collections import deque

class GridType:
    EMPTY = 0
    HOUSE = 1
    WALL = 2

class Solution:
    """
    @param grid: a 2D grid
    @return: An integer
    """
    def shortestDistance(self, grid):
        # write your code here
        M, N = len(grid), len(grid[0])
        # for every empty cell, count for reachable houses
        reach = [[0] * N for _ in range(M)]
        # for every empty cell, sum dist for all reachable houses
        dist = [[0] * N for _ in range(M)]

        # from every house BFS
        house = []
        for i in range(M):
            for j in range(N):
                if grid[i][j] == GridType.HOUSE:
                    house.append([i, j])
        
        for i, j in house:
            q = deque([(i, j, 0)])
            seen = set((i, j))
            while q:
                x, y, step = q.popleft()
                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in seen:
                        seen.add((nx, ny))
                        if grid[nx][ny] == GridType.EMPTY:
                            dist[nx][ny] += step + 1
                            reach[nx][ny] += 1
                            q.append((nx, ny, step + 1))

        # for every empty, find answer
        ans = float('inf')
        for i in range(M):
            for j in range(N):
                if grid[i][j] == GridType.EMPTY and reach[i][j] == len(house):
                    ans = min(ans, dist[i][j])
        
        return [ans, -1][ans == float('inf')]

